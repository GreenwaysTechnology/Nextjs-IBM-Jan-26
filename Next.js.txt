										Next.js

What is Next?
		 Next is a flexible "React framework" that gives you building blocks to create fast "web applications".
		 Next.js created by vercel by extending react's server package

Reacts Packages
1.react-dom/client  ----> client side apps
2.react-dom/server ---->server side apps

What is React?
         	React is JavaScript lib to build "Single Page Web applications"/SPA  (Client side apps)

What is web app?
  Type of distributed app, deployed at server , accessed over network(internet) vi various network protocols like http,  tcp, smtp...
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Response would be document in case if your app is traditional user interface based application.
=>HTML

other responses types incase if your app is "api" based - REST API
=>XML,JSON, Documents, images, videos.........


What is web and why it was created?

  	Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser, launched in 1992.
The first web server is NeXT computer
The first web page , launched http://info.cern.ch/hypertext/WWW/TheProject.html


Technology stack:
................
1.HTML
2.Webserver - Next Computer
3.LineMode Web Browser
4.HTTP protocol.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&	
											Types of Web application
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

1.Static web applications - 1989 to 1995 - till date

    Hard coded html pages, Prepared html pages kept at server, the web server will send those html pages to clients - browsers

Do you think Static web applications still exits?
  Yes!, but we don't prepare the html pages by hand.. rather we ask the server to prepare..

2.Dynamic Content generation application(1996 to till date)

  After 1995, many people thought that how we can use web for biz information system

How to share biz information via internet?
   Generally biz data is stored in databases , how to embed database data into html pages.

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.

Web server core design to get client request and send html response to the client.
Along with web server, something was introduced called "Programming language runtime"

Tech stacks:

1.CGI With C language and Perl script.
2.Java Servlets and JSP
3.Active Server pages - ASP
4.PHP

Are we building apps using this technology even today?
 Yes!

3.Web services-1998 to till date

	 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and receive data because html is just   user interface document language.

 We need , data to be exchanged, that's where new data model was created called 'XML'
xml based web apps called web services.

SOAP protocol was created to transfer XML based documents "SOAP based webservices"

After 2005 SOAP based web services, started failing due to mobile computing.

New Web services  were designed called "Restful Web services"

Restful web services were used to build any type of data formats like json,xml,pdf,html etc...

Are we building apps using this technology even today?
 Yes!

4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using JavaScript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, JavaScript.

Frameworks build based on SPA
1.Angular js |Angular
2.react js
3.vue js
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								.				React as SPA lib
......................................................................................................................................................................................................................................
React.js was created by Facebook , in order to build SPA applications for browsers.

Advantages of SPA:

1.Pages are created  at client side, so server load is completely removed
2.SPA reduces the lot of physical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
................................

1.SEO Challenges
     SPA applications dynamically load content via JavaScript, so search engine crawlers might not see all the page content.
     It impacts poor search ranking and visibility.
2.Inital Load Time
    The browser must download entire js bundle before showing content, but now a days this problem has been fixed using lazy loading feature
3.Security Risks:
     SPAs are Vulnerable to Cross Site Scripting attacks (XSS) 

4.Browser history issues, memory leaks and Performance degradation 


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
			To solve SEO Problems, new Technology was created called "SSR" - Server Side Rendering

		SSR is a technique where your web application's HTML is generated on the server instead of in the browser


Why SSR?
1.Better SEO
   Search engines get complete HTML , making it easier to index.
2.Faster first Paint
    The user sees the page sooner, especially on slow networks
..................................................................................................................................................................................................................................	 											Rendering Types
..................................................................................................................................................................................................................................
What is Rendering?
   Render means preparation, HTML Page preparation...

Rendering Types:
1.CSR- Client side Rendering.
   HTML Pages are prepared at client side - Pure SPA Applications
2.SSR  -Server Side rendering
   HTML Pages are prepared at server side - Dynamic Content Generation applications.

Based on these rendering type, we can classify other rendering

1.Universal rendering /Hybrid Rendering
  Server + Client side , combing both rendering 

2.Full SSR and Partial SSR
    Partial SSR is nothing but only "index.html" is compiled at server , rest of the application is rendered at client side.
    			
					Full SSR is nothing but "index.html" and other pages are compiled at server....


......................................................................................................................................................................................................................................
									      When Rendering can happen
							 		    (when html pages are prepared)
........................................................................................................................................................................................................................................

1.Request time
2.Build time

1.Request time :
 When user types url 

  http://www.example.com/products--------------->Server Receives Request----Prepares Page--send   that page to client.
 Technologies : jsp,asp,php

2.Build time
    Build is nothing but, preparing app for production.. before hosting we have to prepare the   app
    During build phase, we can prepare html pages/render html pages 

SSG -  Static Site Generations:
......................................................
	Building web sites/apps during build phase is called SSG.

Why SSG?
  Super fast page access

							Based On SSG , There is specification is available "JAM Stack"

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									ISR - Incremental Static Rendering
......................................................................................................................................................................................................................................

SSG - Build time or ahead of time
SSR - Request time

ISR = SSG + SSR - Build time + request time 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									What is Next.js?

Next js is a framework that helps to build web apps of all types
  
 you can build Full SSR apps..
 you can build SSR With Request time
 you can build SSG with Build time -  JAM Stacks
 you can build SSR with CSR  - Server + SPA - Hybrid rendering
 you can build rest API also - Web services
 You can build ISR apps - build time + request time

							 "You cant build pure SPA apps like react with redux"

Using Next you can build 
     Pure server side apps with database access, other external API access.....

						Next is full stack framework to build web apps end to end.
				Next uses the javascript as a programming language to build end to end server apps

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
		              				 Next js UI layer - Next JS APP architecture
...........................................................................................................................................................................................................................................
Next js uses "react core features" to build UI layer..., next has been built on the top of core react lib.

Since react is SPA lib, how to build server side apps(SSR)?

React provides two packages:

1.react-dom/client contains APIs to render React components on the client (in the browser). - Pure SPA apps

2.react-dom/server contains APIs to render React components on the server - SSR apps/ISR apps/SSG apps

							    Next.js Framework
							 		|
					-------------------------------------------------------------------
							 react-dom/server package

React core features:
1.React component driven
2.React uses data mutation techniques like props and state
3.React uses event listeners for interactions
4.React hooks

Next.js tech stack:

1.React as ui layer
2.Next does not recommend to use "redux"
3.Next uses api layer- rest api development
4.Next can talk to any database via orm frameworks...

.......................................................................................................................................................................................................................................
									Next js framework and Runtime Architecture
.......................................................................................................................................................................................................................................

Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
	 It is programming language, used to build Next.js apps. Next core engine is written in Rust only.

Next.js Compiler:
..........................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).
	https://swc.rs/docs/getting-started

		SWC allows next js to transform and minify the js code for production. This replaces babel.
					SWC is 20x faster than Babel, it is embedded inside next js

Why SWC
1.It is high performance compiler much faster than babel-20x


Turbo pack:
 	Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. 
 Turbopack can be used in Next.js in both the pages and app directories for faster local development
..........................................................................................................................................................................................................................................
										NEXT JS Getting Started
..........................................................................................................................................................................................................................................

How to install next js and how to create app?

System Req:

1.Node.js 18.18 or later
2.OS - any os
3.vs code.

Installing/Create next app:
..........................

There are two ways :

1.automatic way
   We recommend starting a new Next.js app using create-next-app, which sets up everything automatically for you. To create a project, run:
   npx create-next-app@latest

2.manual way
 Just create folder and app structure your self and install packages
 To manually create a new Next.js app, install the required packages:
 npm install next@latest react@latest react-dom@latest
&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Next application development pattern
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

There are two ways we can build next application

1.Using Page Router
	It is old way / traditional way of building next application , Next version before 13.
	It is not recommended way of building modern next application
2.Using App Router
    It is the latest way of building next application, after next version 12
    It is recommended way of building next application

Languages are used to build next application

1.Typescript
2.Javascript


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Next application development pattern
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

There are two ways we can build next application

1.Using Page Router
	It is old way / traditional way of building next application , Next version before 13.
	It is not recommended way of building modern next application
2.Using App Router
    It is the latest way of building next application, after next version 12
    It is recommended way of building next application

Languages are used to build next application

1.Typescript
2.Javascript

Steps to create project:
.......................................
npx create-next-app@latest
√ What is your project named? ... hello-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
.................................................................................................................................................................................................................................................
								     Exploring Project Structure
............................................................................................................................................................................................................................................

package.json
{
  "name": "hello-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "next": "15.4.6"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4"
  }
}

next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

jsonconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
This is compiler configuration

Tailwind configuration - postcss.config.mjs
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

....................................

src/app

layout.js
page.js
global.css

public 
  Static assets
************************************************************************************************************************************************************
										How to run next app?

dev, build and prod

dev mode:
	>npm run dev

How to prepare your app for production?

First you have to build

   >npm run build

Then you have run in production mode
    >npm start
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					          &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
 					              				Next.js Application Architecture
.......................................................................................................................................................................................................................................
 			               Next.js app is server side app, so for each web page ,the html page is created.
 		        				  "Next App is conventional over Configuration based"

conventional over configuration is a software design principle that reduces the need for explicit configuration by following sensible defaults.
conventional over configuration programming model

let s say some framework eg

i want to build curd operations by connecting mongodb

employee - domain folder
 entity
    enity.config.js
    id name salary department
 
ask the framework to generate code for you...
 
somthing.save()
something.read()
something.update()

Like above, next is also following conventional over configuration pattern
file names and folder names are standard based.

Basic folder structure : for app router pattern

src - root folder
 |
 app - sub folder
   |
  any folder- domain folder eg: contacts ,products,customers

filenames are predefined...like page.js , layout.js

FileNames:(in built files /conventional file names)
fileName.js | ts | jsx | tsx

1.layout.js
2.page.js
3.template.js
4.route.js
5.error.js
6.not-found.js
7.global-error.js
8.loading.js
9.default.js

 		Apart from the above file names we can create our won files like Products.js|jsx - Colocation


.......................................................................................................................................................................................................................................
										 React core features inside next js
........................................................................................................................................................................................................................................
1.Component:
	  In react every thing is component, in next also the component driven arch is followed.
2.Props
    In react data is passed to the component via props.
Why:
       Components are created in a configurable way..

Types of Props:

1.Data as prop:

function User(props){
   return <div>
		<h1>{props.id} {props.name}</h1>
  <div>
}

   <User id={1} name={'Subramanian'} />

2.State as Prop -Dynamic Prop

  function User(){
    const [id,setId] = useState(1)
    return <UserDetails id={id} />
  }

3.function as Prop- Listeners as Prop

  function User(){
    const [id,setId] = useState(1)
    return <UserDetails setId={setId} />
  }

4.Component as Prop

Component as Prop syntax we use heavily in Next.js

Component Rendering:

function Tab(props){
   return <> {props.children} </>
}
<Tab/> - Self Closing
  This component has no children

<Tab>
    <Grid/> -  Component as Prop
<Tab>
..........................................................................................................................................................................................................................................
 										 Every thing is component  in Next.js
.........................................................................................................................................................................................................................................
core /built in components;

Page Component: - page.js
  It is place holder component which displays ui.

Layout Component: layout.js
 	 It is container component which holds Page Component

Parent and child:

Pattern 1:

function Page() {
    **return <h1>Home Page</h1>**

}
function Layout(){
**return <Page/>**

}

Pattern 2:
function Page() {
    return <h1>Home Page</h1>
}
function Layout(props){
**return <div>{props.children}</div>**

}

function App(){
 return <Layout>
 	<Page/>
</Layout>
}

In Next js we use pattern 2,
You cant  supply your own entry function, Next, internally suppiles

Every next application begins /starts with root layout - src/app/layout.js

layout - parent
 	  ------------------------------
          |                             |
                      Page -child |
          |                             |
          |                             |
          |                             |
           -----------------------------

<Layout>
    <Page/>
</Layout>

How to declare in built components (page,layout etc...) ?

 1.every component must be "functional component" - No Class Component.
 2.every in built component (page,layout...)  must be exported using "export default" only.
 3.Every Next application must have "root layout" src/app/layout.js
 4.Every Next application may have  "home/landing page" src/app/page.js
 5.Component Name can be any thing like HomePage,Home,MyHomePage,MyLayout etc..

page.js | page.jsx | page.tsx
layout.js | layout.jsx | layout.tsx


How to create Page and layout Components ?

src/page.js

function Home() {
  //you must return jsx
  return <div>
    <h1>Home Page</h1>
  </div>
}

export default Home;

src/app/layout.js
export default function RootLayout(props) {
    return <html lang="en">
        <body>
            {props.children}
        </body>
    </html>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Layouts and Pages-Routing
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

What is Routing?
	Routing is nothing but mapping resources against url.

Next.js uses "file-system based routing" , meaning you can use folders and files to define routes.

Types of Routing implementation:

1.page routing
    It is old form of routing pattern, now it is not used
   page routing was available before next.js version 12

2.app routing
    It is modern form of routing pattern, now it is heavily used
    app routing has been available from next.js version 13 onwards
create a page and map against url:
.........................................................

A page is UI that is rendered on a specific route. in order to create a page, "add page.js or page.jsx or page.tsx page.ts".

Route:
   means URL  ----> /products , /customers , /comments
       route is mapped against folder
  src/app/products/page.js   ------> /products

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
√ What is your project named? ... core-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

index route /Home route:
.........................................

src/app/page.js ->index route

 if you create page.js inside src/app folder which is called index route or home route.

........................................................................................................................................................................................................................................
										Nested Folders and Routing
.....................................................................................................................................................................................................................................

products page:

Folder structure
src/app/products/page.js
src/app/customers/page.js
src/app/contact/page.js

URL
/products

export default function ProductPage() {
    return <div>
        <h1>This is Product Page...Comming soon</h1>
    </div>
}

/customers
export default function CustomerPage(){
      return <div>
        <h1>Customer Page</h1>
      </div>
}
/contacts
export default function ContactPage() {
    return <div>
        <h1>Contact Page</h1>
    </div>
}
.......................................................................................................................................................................................................................................
										Deep Nesting

URL
/products/reviews/comments

src/app/products/reviews/comments/page.js
export default function Reviews(){
    return <h1>Reviews Page</h1>
}

URL
/products/reviews/page

src/app/products/reviews/page.js
export default function Reviews(){
    return <h1>Reviews Page</h1>
}

Hands on :
					   You create a route for courses, training ,instructor
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										&&&&&&&&&&
									   Nested Layout
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Nested layout is optional only, if you want nested layout, which is shared among nested pages.

layout.js - File Convention for nested layout also.

<Layout> -- root layout
	<Layout> --nested layout
		<Page/>
	</Layout>
</Layout>

eg:
src/app/customer/layout.js

export default function CustomerLayout(props) {

    return <div id="customerlayout">
        {/* Customer Page is inserted here */}
        {props.children} 
    </div>

}

Deep Nested Layouts:

src/app/products/layout.js
export default function ProductLayout({ children }) {
    return <div id="productLayout">
        {children}
    </div>
}
src/app/products/reviews/layout.js
export default function ReviewsLayout({ children }) {
    return <div id="reviewsLayout">
        {children}
    </div>
}
src/app/products/reviews/comments/layout.js

export default function CommentsLayout({ children }) {
    return <div id="commentsLayout">
        {children}
    </div>
}

Hands on:
Create Dashboard  having the following routes - create nested layouts
/dashboard
/dashboard/users
/dashboard/users/settings

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Component Driven Archiecture
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Layout is container Component, Page Component is mapped against route segment, which displays UI.

Can Page Hold other Components?

Yes
    Layout
          | 
       Page
            |
 UserProfile
     |
    UserList
      |
      UserItem

Project:
√ What is your project named? ... components-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

Without extra Components:

src/app/todos/layout.js
export default function TodosLayout({children}){
    return <div id="todosLayout">
         {children}
    </div>
}
src/app/todos/page.js
import TODOS from "../mock-data/todos"
export default function TodosPage() {
    return <>
        <h1>Todos Page</h1>
        <ul>
            {TODOS.map(todo => {
                return <li key={todo.id}>
                    <span>{todo.title} {todo.status ? "Completed" : "In Progress"}</span>
                </li>
            })}
        </ul>
    </>
}

Here we have dumpted todos ui inside page.js , which is not recommended, you have to have separate component.

src/app/todos/components/TodoList.jsx
import TODOS from "../../mock-data/todos"

export function TodoList() {
    return <ul>
        {TODOS.map(todo => {
            return <li key={todo.id}>
                <span>{todo.title} {todo.status ? "Completed" : "In Progress"}</span>
            </li>
        })}
    </ul>
}
src/app/todos/page.js
import { TodoList } from "./components/todosList";

export default function TodosPage() {
    return <>
        <TodoList />
    </>
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										import aliases
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Import aliases in Next.js , in javascript or typescript projects generally provide a way to create shorter,more readable and less error-prone import paths instead of using long relative paths

eg:
 ../../
../../../components/Mycomponent

import TODOS from "../../mock-data/todos"

Using Import aliases Syntax:

@/app/yourFolder/YoursubFolder/fileName

import TODOS from "@/app/mock-data/todos"


eg:

import TODOS from "@/app/mock-data/todos"
export function TodoList() {
    return <ul>
        {TODOS.map(todo => {
            return <li key={todo.id}>
                <span>{todo.title} {todo.status ? "Completed" : "In Progress"}</span>
            </li>
        })}
    </ul>
}

// import { TodoList } from "./components/todosList";
import { TodoList } from "@/app/todos/components/todosList"
export default function TodosPage() {
    return <>
        <TodoList />
    </>
}

Task:
Display Post Details using components
Mock data : https://jsonplaceholder.typicode.com/posts
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											 Components Types
											  (Rendering Types)
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Rendering is nothing but page preparation (html creation).

How to create html and where to create Html?

Where:
     rendering can take place in the server or on the client.

When:
  At Server side:
    It can happen either ahead of time during build time.
    or on every Request at runtime.

With next js , two types of rendering methods are available.

1.Server-side rendering
   1.0. Request time
   1.1. Static site Generation - build time
   1.2. ISR - Incremental Static rendering - first Build time and later runtime.

2.Client-side Rendering
   Preparing portion of page at client side , which is similar to SPA Apps. -  It is just like JQuery with Php/Java/DotNet

Component types:
 Based on Rendering, we can classify the component into two category.

1.Server Component
   Server components are rendered at server side
2.Client components
   Clients components are rendered at client side

					By default all components are "Server Rendered Components"

   page,layouts,templates,notfound,loading,default all are server components only

Even When we create custom components

export default function Greet(props) {
     return <>
        <h1>{props.message}</h1>
     </>
}
...........................................................................................................................................................................................................................................
										 	Client Component
...........................................................................................................................................................................................................................................
Component which may have logic to interact with user like button clicks,typing,animations,data fetch at client side,hooks, any dom manipulation......

The components can be co-located..

	Client components allow us to write interactive UI that is prendered on the server and can use client javascript to run in the browser.

Advantages of client Rendering:

1.Interactivity
   Client components uses "state,effects,event listener" , meaning they can provide immediate feedback to the user and update the UI.

2.Browser APIs:
     Client components have access the browser apis like Storage,geo location....


src/app/counter/components/Counter.jsx
import { useState } from "react"

export function Counter() {
    const [value, setValue] = useState(0)

    return <>
        <h1>Value : {value}</h1>
    </>
}

src/app/counter/page.js
import { Counter } from "@/app/counter/compoents/Counter";

export default function CounterPage(){
    return <div>
        <h1>Counter</h1>
        <Counter/>
    </div>
}
After running:

./src/app/counter/compoents/Counter.jsx (1:10)

Ecmascript file had an error
> 1 | import { useState } from "react"
    |          ^^^^^^^^
  2 |
  3 | export function Counter() {
  4 |     const [value, setValue] = useState(0)

You're importing a component that needs `useState`. This React Hook only works in a Client Component. To fix, mark the file (or its parent) with the `"use client"` directive.

 Learn more: https://nextjs.org/docs/app/api-reference/directives/use-client

Import trace:
  ./src/app/counter/compoents/Counter.jsx
  ./src/app/counter/page.js


How to fix this?

Convert the component into client components, so that next will bundle this component and send to the browser, so browser starts hyderating this code.

How to tell to the next server?

//directive is nothing but instructions to the compiler

"use client" // directive

import { useState } from "react"

export function Counter() {
    const [value, setValue] = useState(0)

    return <>
        <h1>Value : {value}</h1>
        <button onClick={() => {
            setValue(value + 1)
            console.log(value)
        }}>+</button>
    </>
}

How to know the client component?

if component has 

1.useState hook or any hook
2.Any listener
3.useEffect hook
4.Browser apis
5.state declaration

Task:
  CURD operation using Array

'use client'
import { useState } from "react"

export default function Post() {
    const [posts, setPosts] = useState([{
        id: 1, title: 'React', body: 'This is React Post'
    },
    {
        id: 2, title: 'Angular', body: 'This is Angular Post'
    }
    ])
    //Edit or update status
    const [isEditing, setIsEditing] = useState(false)
    const [form, setForm] = useState({ title: '', body: '', id: null })

    const handleSubmit = (e) => {
        e.preventDefault()
        isEditing ? updatePost() : addPost()
    }
    const updatePost = () => {
        console.log('updatePost')
        setPosts(posts.map(post => post.id === form.id ? form : post))
        setIsEditing(false)
        clearForm()
    }
    const addPost = () => {
        //console.log('addPost')
        const newPost = { id: posts.length + 1, form: form.title, body: form.body }
        setPosts([...posts, newPost])
        clearForm()
    }
    const clearForm = () => {
        setForm({ title: '', body: '', id: null })
    }
    const handleEdit = (post) => {
        setIsEditing(true)
        setForm({ title: post.title, body: post.body, id: post.id })
    }
    const handleDelete = id => {
        setPosts(posts.filter(post => post.id !== id))
    }


    // render list of posts
    return <div>
        {/* form to add edit posts */}
        {/* Todo: remove this once the testing is over */}
        {JSON.stringify(form)}
        <form onSubmit={handleSubmit}>
            <div style={{ marginBottom: 10 }}>
                <input onChange={(e) => {
                    setForm({ ...form, title: e.target.value })
                }} value={form.title} placeholder="Title" />
            </div>
            <div style={{ marginBottom: 10 }}>
                <textarea onChange={(e) => {
                    setForm({ ...form, body: e.target.value })
                }} value={form.body} placeholder="Body"></textarea>
            </div>
            <div style={{ marginBottom: 10 }}>
                <button className="focus:outline-none text-white bg-green-700 hover:bg-green-800 focus:ring-4 focus:ring-green-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-green-600 dark:hover:bg-green-700 dark:focus:ring-green-800">{isEditing ? "Update" : "Add "}Post</button>
            </div>
        </form>
        <ul>
            {
                posts.map(post => {
                    return <li key={post.id}>
                        <h1>{post.title}</h1>
                        <p>{post.body}</p>
                        <button onClick={() => {
                            handleEdit(post)
                        }} className="focus:outline-none text-white bg-green-700 hover:bg-green-800 focus:ring-4 focus:ring-green-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-green-600 dark:hover:bg-green-700 dark:focus:ring-green-800">Edit</button>
                        <button onClick={() => {
                            handleDelete(post.id)
                        }} className="focus:outline-none text-white bg-red-700 hover:bg-red-800 focus:ring-4 focus:ring-red-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-red-600 dark:hover:bg-red-700 dark:focus:ring-red-900">Delete</button>
                    </li>
                })
            }
        </ul>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\										Patterns for client and server components
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

1.Server component uses another Server Component
   inside layout.js we use page.js
   inside page.js we use UserList.js

2.Server component uses client component

3.Client component uses another server component

4.Client component uses another client component

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					  1.Server component uses another Server Component

Rules:
Any server can use any server component without using any special keywords

app/patterns/serverusesserver/layout.js
//server component
export default function ServerLayout({children}) {
     return <div>
            {children}
     </div>
}

app/patterns/serverusesserver/page.js

import Hello from "@/app/patterns/serverusesserver/components/Hello";


export default function ServerPage() {
    return <>
        <h1>Server Page</h1>
        <Hello/>
    </>
}

app/patterns/serverusesserver/components/Hello
//server component
export default function Hello() {
    return <h1>Hello Component</h1>
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								2.Server component uses client component
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Rules:
1.If server components uses client, the client component must be marked 'use client' directive, if you dont mark , you get "build time" error


app/patterns/serverusesclient/page.js

app/patterns/serverusesserver/layout.js
//server component
export default function ServerLayout({children}) {
     return <div>
            {children}
     </div>
}

app/patterns/serverusesserver/page.js
import { Counter } from "@/app/patterns/serverusesclient/components/Counter";


export default function ServerPage() {
    return <>
        <h1>Server Page</h1>
        <Counter />
    </>
}
app/patterns/serverusesserver/components/Counter.jsx
'use client'
import { useState } from "react"

export function Counter() {
    const [counter, setCounter] = useState(0)
    return <div>
        <h1>Counter : {counter}</h1>
        <button onClick={() => {
            setCounter(counter + 1)
            console.log(counter)
        }} className="text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-4 focus:ring-gray-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-gray-800 dark:hover:bg-gray-700 dark:focus:ring-gray-700 dark:border-gray-700">+</button>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Client component uses another server component
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

app/patterns/clientusesserver/layout.js
//server component
export default function ServerLayout({children}) {
     return <div>
            {children}
     </div>
}
app/patterns/clientusesserver/page.js
import { Counter } from "@/app/patterns/clientusesserver/components/Counter";


export default function ServerPage() {
    return <>
        <Counter />
    </>
}

app/patterns/clientusesserver/components/CounterHeader.jsx
//server component
export default function CounterHeader(){
        return <h1>Counter App!!</h1>
}

app/patterns/clientusesserver/components/Counter.jsx

'use client'
import { useState } from "react"

import CounterHeader from "@/app/patterns/clientusesserver/components/CounterHeader";

export function Counter() {
    const [counter, setCounter] = useState(0)
    return <div>
        {/* Server Component: Client Component uses another Component */}
        <CounterHeader />
        <h1>Counter : {counter}</h1>
        <button onClick={() => {
            setCounter(counter + 1)
            console.log(counter)
        }} className="text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-4 focus:ring-gray-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-gray-800 dark:hover:bg-gray-700 dark:focus:ring-gray-700 dark:border-gray-700">+</button>
    </div>
}

Rules
			 if client uses another server component,"server component automatically becomes client component"
						 	When we use this pattern we loose server rendering

In the above code Server component runs in the client only.
***********************************************************************************************************************************************************
				What if "client uses server component" but at the same time, i dont want to loose server rendering feature?
Solution:
     Pass Server Component as Prop to Child  component.

app/patterns/clientusesserver/layout.js
//server component
export default function ServerLayout({children}) {
     return <div>
            {children}
     </div>
}
app/patterns/clientusesserver/page.js
import { Counter } from "@/app/patterns/clientusesserver/components/Counter";
import CounterHeader from "@/app/patterns/clientusesserver/components/CounterHeader";


export default function ServerPage() {
    return <>
        {/* <Counter /> */}
        {/* Pass Server Component as Prop */}
        <Counter>
            <CounterHeader/>
        </Counter>
    </>
}
app/patterns/clientusesserver/components/CounterHeader.jsx
//server component
export default function CounterHeader(){
        return <h1>Counter App!!</h1>
}

app/patterns/clientusesserver/components/Counter.jsx

'use client'
import { useState } from "react"

// import CounterHeader from "@/app/patterns/clientusesserver/components/CounterHeader";


export function Counter(props) {
    const [counter, setCounter] = useState(0)
    return <div>
        {/* Server Component: Client Component uses another Component
        <CounterHeader /> */}

        {/* Receive Server Component as Child */}
        {props.children}

        <h1>Counter : {counter}</h1>
        <button onClick={() => {
            setCounter(counter + 1)
            console.log(counter)
        }} className="text-white bg-gray-800 hover:bg-gray-900 focus:outline-none focus:ring-4 focus:ring-gray-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 dark:bg-gray-800 dark:hover:bg-gray-700 dark:focus:ring-gray-700 dark:border-gray-700">+</button>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Client Component uses another client Component
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

app/patterns/clientusesclient/layout.js
//server component
export default function ServerLayout({children}) {
     return <div>
            {children}
     </div>
}
app/patterns/clientusesclient/page.js
import ClientOne from "@/app/patterns/clientusesclient/components/ClientOne";


export default function ServerPage() {
    return <>
        <ClientOne />
    </>
}
app/patterns/clientusesclient/components/ClientOne.jsx
'use client'

import ClientTwoComponent from "@/app/patterns/clientusesclient/components/ClientTwo";

export default function ClientOneComponent() {

    return <>
        <h1>Client One</h1>
        <ClientTwoComponent />
    </>

}
app/patterns/clientusesclient/component/ClientTwo.jsx

'use client'

export default function ClientTwoComponent() {

    return <>
        <h1>Client Two</h1>
    </>

}
Note :

	  If client component uses another client component, that another client component no need to use 'use client' directive.
								Incase the same client used by another server component,				
									'use client' directive must be three
eg:
app/patterns/clientusesclient/component/ClientTwo.jsx

export default function ClientTwoComponent() {

    return <>
        <h1>Client Two</h1>
    </>

}

React carbon Integration:

1.npm install -S @carbon/react

app/patterns/clientusesclient/component/MyButton.jsx

'use client'

import { Button } from "@carbon/react"

export default function MyButton() {

    return <div>
        <h1>React Carbon Lib</h1>
        <Button>Hello</Button>
    </div>

}

app/patterns/clientusesclient/page.js
import MyButton from "@/app/patterns/clientusesclient/components/MyButton";
export default function ServerPage() {
    return <>
        <MyButton />
    </>
}


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									       Linking and Navigation
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

In order to understand how navigation works in Next.js we need to know the common concepts

1.Server Rendering
2.Prefeching 
3.Streaming
4.Client-side Transitions

1.Server Rendering
 
Layouts and Pages are React Server Components by default, on Initial and subsequent navigations, the "React Server Component Payload" (RSC) Payload is generated on the server before being sent to the client.

hello.java -source code
|
compile
hello.class -  byte code
|
execute
|
you will get output

page.js - source code
|
compile - turbopack | swc
|
server component 
|
rsc payload - React Server Component Payload - compiled
	
rsc :
  It is compact binary format that encodes the rendered output of your server component tree, This payload is streamed from the server to client
 RSC payload is binary/JSON-like stream that describes
->Component tree
->Props
->References to Client Component
->Serialized data
->Module identifiers

It is not raw html 
It is not raw java script code

Think of it is as
						  "Instructions for react to rebuild UI Structure"

What is sent to the browser?
    1.HTML Shell/Template (initial rendering/ for fast paint)
    2.RSC Payload (Streaming)

<script src="react-dom.js"></script> ---->engine code
<script src="react.js"></script>
<script src="main_bundle.js"></script>

php / servlets/jsp / aspx
hello.php ------>hello.html - pure html

hello.js---------->(rsc payload) hello.html - not pure html
							<html>
								<head>
									 it will add all js libs/ and app code and css will be included
								<body>
							 </body>
							 </html>


next.js code--compile---RSC Payload (server component code ,client component code)  ---rendered as html
RSC payload is compact binary representation of next.js code

Server Component Payload:
   It is internal json like structure, it is compiled image from jsx/js/tsx file.

 Source code---->Next.js Compiler---->React Server Component Payload (RSC P)------>Sent to the Client(browser)----->Browser downloads the RSC Payload ,Construct DOM tree.

There are two types of Rendering, based on "When" it happens

1.Static Rendering (or Prerendering) happens at build time or during revalidation and the result is cached (ISR)

2.Dynamic Rendering  happens at "request time" in response to a client request.

Draw backs of Server Rendering:
.....................................................
	The trade-off server rendering is that the client must wait for the server to response before the new route can be shown.
							But Next.js has taken step to improve or avoid this drawback

					  	By Introducing  features called "prefetching"  and "Client side transitions" ,and also Streaming



Prefetching:
.....................
			Prefetching is the process of loading a route in the background before the user navigates to it
This makes navigation between routes in your application feel instant, because by the time a user clicks on a link, the data render the route is already available in the client side.

How much of the route is prefetched depends on whether it's static or dynamic

1.static route : the full route is prefetched.
2.dynamic route: prefetching is skipped by default, or the route is partially prefetched if "loading.jsx" is present

Why dynamic route is skipping  prefetching?		

		By Skipping or Partially prefetching dynamic routes, Next tries to avoid unnecessary work on the server for routes the users may never visits.
		How ever , waiting for a server response before navigation can give the users the impression that the app  is not responding

How to inform the user that app is loading? 

	You have to show that the app is still active -  You can show some progress bar.

Streaming:

		Streaming allows the server to send "parts of a dynamic route" to the client as soon as they are ready, rather than waiting for 
		the entire route to be rendered. This means users see something sooner, even if parts of the page are still loading.


 For dynamic routes, it means they can be partially prefetched , that is shared layouts and loading spinners can be requested ahead of time.

Client Side transitions:
	
	Traditionally, navigation to a server-rendered page triggers a full page reload. This clears state, resets scroll position, and blocks 	 	interactivity.
    	  Client side transitions feature in Next.js refers to navigating between pages or routes within app without fully reloading the browser.
        This results in faster, smoother navigation with instant consent rendering and state preservation in SPA style.
    
when navigation
   ->Does not reload the page 
  -> Uses java script router 
  ->Fetch RSC Payload, not full html
   ->Preserves layout state

Next.js avoids this with client-side transitions using the <Link> Component , instead of reloading the entire page, it updates the content dynamically by

	1.Keeping any shared layouts and UI
	2.Replacing the current page with prefeched loading state or new page if available.
	Client side transitions are what makes a server-rendered apps feel like client rendered pages, along with prefetching and streaming
	it enables fast transitions, even for dyamic routes.

What actually happens (Step by step)

inital load
  Browser-------->Server ---->returns ------->HTML +RSC Payload

Client side transition (when you click hyper link)

Click Link
  |
Next router intercepts
|
Fetch ?_rsc=xxxxx
|
Receive RSC flight Payload
|
Download payload
|
React reconciles tree
|
DOM updates(no reload)


What can make transitions slow?

1.Dynamic routes without loading.js or React.Suspense
2.Dynamic segements  without generateStaticParams
3.Slow networks
4.Disable prefeching 
5.Hydration not completed
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Navigation Implementation
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

There are four ways to navigate between routes in Next.js

- Using the <Link> Component (Client Component)
- Using useRouter hook (Client Component)
- Using the native browser History API (Client)
- Using redirect function (Server component)

Navigation can happen  in two places

1.Server side redirection/navigation
   Redirection is controlled by Server

2.Client Side Redirection/Navigation
   Redirction is controlled by browser

Server Redirection:
1.redirect function
2.permantRedirect function
3.routeConfig file
4.API redirections - NextReponse.redirect

Client Side Naviation:
1.Link component
2.useRouter Hook
3.Browser Native History API.

Project:
√ What is your project named? ... linking-navigation
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

Link Component:

 Link is react component that extends the HTML <a> element to provide client side navigation between routes.

 Link component has lot of properties
 1.href
 2.replace
 3.scroll
 4.prefech

Basic Navigation

src/app/layout.js
import Link from "next/link";


export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>
          <h1>Header</h1>
          <nav>
            <ul>
              <li>
                <Link href={{ pathname: "/about" }}>About</Link>
              </li>
              <li>
                <Link href={{ pathname: "/services" }}>Services</Link>
              </li>
            </ul>
          </nav>
        </header>
        {/* Body : page */}
        {children}
        <footer>
          <p>This is footer</p>
        </footer>
      </body>
    </html>
  );
}

src/app/about/layout.js
export default function AboutLayout(props) {
    return <div id="aboutLayout">
        {props.children}
    </div>
}
src/app/about/page.js
export default function About(){
    return <div>
        <h1>About</h1>
    </div>
}


src/app/services/layout.js
export default function ServicesLayout(props) {
    return <div id="servicesLayout">
        {props.children}
    </div>
}

src/app/services/page.js

export default function Services(){
    return <div>
        <h1>Services</h1>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									   Create Nav Bar Component
*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

src/app/components/NavBar.jsx
import Link from "next/link"

export default function NavBar() {
    return <nav>
        <ul>
            <li>
                <Link href={{ pathname: "/about" }}>About</Link>
            </li>
            <li>
                <Link href={{ pathname: "/services" }}>Services</Link>
            </li>
        </ul>
    </nav>
}
src/app/layout.js
import NavBar from "@/app/components/NavBar";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>
          <h1>Header</h1>
           <NavBar/>
        </header>
        {/* Body : page */}
        {children}
        <footer>
          <p>This is footer</p>
        </footer>
      </body>
    </html>
  );
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Active Links
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

If you want to highlight which menu we have clicked, we can  show the menu highlighted

How to enable active link feature?

you can use hook "usePathname()" to determine if link is active or not.

For example to add a css class to the active link, you can check the current pathname matches  of the link.

src/app/links.css
.active {
    background-color: aqua;
}

src/app/components/NavBar.jsx

'use client
import Link from "next/link";
import { usePathname } from "next/navigation"
import '@/app/links.css'

export default function NavBar() {
    const pathname = usePathname()
    // console.log(pathname)
    return <nav>
        <ul>
            <li>
                <Link className={`${pathname === '/about' ? 'active' : ''}`} href={{ pathname: '/about' }}>About</Link>
            </li>
            <li>
                <Link className={`${pathname === '/services' ? 'active' : ''}`} href={{ pathname: '/services' }}>Services</Link>
            </li>
        </ul>
    </nav>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										useRouter Hook
...........................................................................................................................................................................................................................................
useRouter hook allows you programmetically change route from client components.

src/app/dashboard/components/DashboardNavigator.jsx
'use client'

import { useRouter } from "next/navigation"

export function DashBoardNavigator() {
    const router = useRouter()
    return <div>
        <button onClick={() => {
            router.push('/services')
        }}>Services</button>
        <button onClick={() => {
            router.push('/about')
        }}>About</button>
    </div>
}

src/app/components/NavBar.jsx
'use client'
import Link from "next/link"
import { usePathname } from "next/navigation"
import '../link.css'

export default function NavBar() {
    const pathname = usePathname()
    // console.log(pathname)
    return <nav>
        <ul>
            <li>
                <Link className={`${pathname === '/about' ? 'active' : ''}`} href={{ pathname: '/about' }}>About</Link>
            </li>
            <li>
                <Link className={`${pathname === '/services' ? 'active' : ''}`} href={{ pathname: '/services' }}>Services</Link>
            </li>

              <li>
                <Link className={`${pathname === '/dashboard' ? 'active' : ''}`} href={{ pathname: '/dashboard' }}>DashBoard</Link>
            </li>
        </ul>
    </nav>
}

src/app/dashboard/page.js
import { DashBoardNavigator } from "@/app/components/DashboardNavigator";

export default function Dashboard() {
    return <DashBoardNavigator />
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Advanced Routes - Dynamic Routes -Dynamic Route Segement

What is Dynamic Route?
	   When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

URL pattern:
/users/1
/posts/comments/1
	
How to create dynamic route?

Convention:
    A dynamic segment can be created by wrapping a folder's name in square brackets.
  [folderName]
   eg:
     [id] or [city] or [slug]
      |
     place holder.


 What is your project named? ... dynamic-routes
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Building Master Details Pages
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Ways to build:
1.Using mock data
2.Using api call

Using Mock data:

src/app/todos/page.js
import TODOS from "@/app/mock-data/todos";
import Link from "next/link";

export function fetchTodos() {
    return TODOS
}

export default function TodoPage() {
    const todos = fetchTodos()

    return <>
        <ul>
            {todos.map(todo => {
                return <li key={todo.id}>
                    <Link href={{ pathname: `/todos/${todo.id}` }}>
                        <span>{todo.title}</span>
                    </Link>
                </li>
            })}
        </ul>
    </>
}

src/app/todos/[id]/page.js
export default function TodosDetailsPage() {
    return <div>
        <h1>Details Page</h1>
    </div>
}

Here if you want to read the parameter of todoId, Next.js will supply id value as params via props


export default function TodosDetailsPage(props) {
    console.log(props.params)
    return <div>
        <h1>Details Page</h1>
    </div>
}
Promise {
  <pending>,
  id: '8',
}
Here you can see that props.params returns Promise, if you want to read id value, you have to use then or you have to use async...await

export default function TodosDetailsPage(props) {
    console.log(props.params.id)
    return <div>
        <h1>Details Page</h1>
    </div>
}

Error: Route "/todos/[id]" used `params.id`. `params` should be awaited before using its properties. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis
    at TodosDetailsPage (src\app\todos\[id]\page.js:2:29)
  1 | export default function TodosDetailsPage(props) {
> 2 |     console.log(props.params.id)
    |                             ^
  3 |     return <div>
  4 |         <h1>Details Page</h1>
  5 |     </div>

how to read id?

import TODOS from "@/app/mock-data/todos";
import Link from "next/link";

export function fetchTodoById(id) {
    return TODOS.find(todo => todo.id === id)
}
export default async function TodosDetailsPage(props) {
    //console.log(props.params.id)
    const id = (await props.params).id
    const todo = fetchTodoById(+id)
    return <div>
        <h1>{todo.id}</h1>
        <h2>{todo.title}</h2>
        <h2>{todo.completed ? "Completed" : "InProgress"}</h2>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								Master details page - Using API Calls
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Master Page:

src/app/posts/page.js
import Link from "next/link"

export async function fetchPosts() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts')
    return response.json()
}

export default async function PostsPage() {
    const posts = await fetchPosts()
    return <div>
        <ul>
            {posts.map(post=>{
                return <li key={post.id}>
                    <Link href={{pathname:`/posts/${post.id}`}}>
                        <span>{post.title}</span>
                    </Link>
                </li>
            })}
        </ul>
    </div>
}

src/app/posts/[id]/page.js
export async function fetchPostById(id) {
    const url = `https://jsonplaceholder.typicode.com/posts/${id}`
    const response = await fetch(url)
    return response.json()
}

export default async function PostDetailsPage(props) {
    const id = (await props.params).id
    const post = await fetchPostById(+id)
    return <div>
        <section>
            <h1>id:{post.id} userId: {post.userId}</h1>
            <p>{post.title}</p>
            <p>{post.body}</p>
        </section>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Shallow Routing
	Shallow routing in Next.js is a technique that updates the URL in the browser without triggering a full page reload or re-running the data fetching methods generateStaticParams.

This is useful for UI updates that should reflect in the URL but don't require fetching new data or re-rendering the entire page.

How Shallow Routing Works

It updates the path or query parameters using the HTML5 History API without causing a full navigation.
Keeps the current state and component tree intact, avoiding expensive data refetches.
Only works for URL changes within the same page route.

Key Points

1.Calling router.push with { shallow: true } changes the URL but keeps the page and state intact.

Useful for paginations, tabs, filters where data fetching does not need to be repeated.

If you navigate to a completely different page route, shallow routing will not apply and the full page reload will happen.

Shallow routing optimizes user experience by minimizing reloads and preserving UI state while making the URL reflect current app state.

Shallow routing syntax:

 router.push('path',data,{shallow:true})

Parameters:
1.dynamic parameter
    /products/1 or /products/2
2.Query Parameter
  /products?page=1
	|             |
	URL    Query parameter(variable)=value

app/products/page.js
import Pagination from './components/Pagination'


export default async function ProductsPage() {
  return (
    <main>
      {/* Pagination component handles client-side navigation */}
      <Pagination />
    </main>
  )
}

app/products/components/Pagination.jsx
'use client'

import { useRouter, useSearchParams } from 'next/navigation'
import { useState, useEffect } from 'react'

// Mock data array simulating products
const allProducts = [
    'Product 1',
    'Product 2',
    'Product 3',
    'Product 4',
    'Product 5',
    'Product 6',
    'Product 7',
    'Product 8',
    'Product 9',
    'Product 10',
]

// items per page
const pageSize = 3 

export default function Pagination() {
    const router = useRouter()
    const searchParams = useSearchParams()
    const initialPage = Number(searchParams.get('page')) || 1

    const [page, setPage] = useState(initialPage)

    // Calculate the slice of products for the current page
    const pagedProducts = allProducts.slice(
        (page - 1) * pageSize,
        page * pageSize
    )

    const changePage = (newPage) => {
        // Ensure page is within total page count bounds
        if (newPage < 1 || newPage > Math.ceil(allProducts.length / pageSize)) {
            return
        }

        setPage(newPage)
        //
        router.push(`/products?page=${newPage}`, undefined, { shallow: true })
    }

    useEffect(() => {
        const currentPage = Number(searchParams.get('page')) || 1
        if (currentPage !== page) {
            setPage(currentPage)
        }
    }, [searchParams])

    return (
        <div>
            <h1>Paginated Product List</h1>
            <ul>
                {pagedProducts.map((product, index) => (
                    <li key={index}>{product}</li>
                ))}
            </ul>

            <button disabled={page <= 1} onClick={() => changePage(page - 1)}>
                Previous
            </button>
            <button
                disabled={page >= Math.ceil(allProducts.length / pageSize)}
                onClick={() => changePage(page + 1)}
            >
                Next
            </button>
            <p>Page {page} of {Math.ceil(allProducts.length / pageSize)}</p>
        </div>
    )
}

app/layout.js
       <nav>
          <ul>
            <li>
              <Link href={{ pathname: "/products" }}>Products (Using  Swallow Routing-Pagination)</Link>
            </li>
          </ul>
        </nav>
************************************************************************************************************************************************************
										Server side Pagination 
									
This pattern gives you SEO-friendly, scalable pagination, works with any data source, and keeps your Next.js app efficient and indexable

How to convert  Client Pagination to Server side Pagniation?

Via <Link> Component - Server side Pagination

app/products/components/
styles.css
.disabled {
  pointer-events: none;   /* stops click */
  opacity: 0.5;           /* visual disabled */
  cursor: not-allowed;
}

app/products/components/ServerPagination.jsx
import Link from 'next/link'
import './styles.css'

export default function ServerPagination({ currentPage, totalPages }) {
    console.log(currentPage)
    return (
        <nav>
            {currentPage > 1 ? (
                <Link href={`/products?page=${currentPage - 1}`}>
                    Previous    |
                </Link>
            ) : (
                <span className="disabled">Previous | </span>
            )}
            {currentPage < totalPages ? (
                <Link href={`/products?page=${currentPage + 1}`}>
                    Next
                </Link>
            ) : (
                <span className="disabled">Next</span>
            )}
            <div>
                <span>Page {currentPage} of {totalPages}</span>
            </div>

        </nav>
    )
}


app/products/page.js
import ServerPagination from './components/ServerPagination'

// Mock product data (replace with DB/API fetch in production)
const allProducts = [
    'Product 1', 'Product 2', 'Product 3', 'Product 4', 'Product 5',
    'Product 6', 'Product 7', 'Product 8', 'Product 9', 'Product 10'
]
const pageSize = 3

export default async function ProductsPage({ searchParams }) {
    //searchParam is promise
    const resolvedSearchParams = await searchParams

    const page = Number(resolvedSearchParams.page) || 1

    const totalPages = Math.ceil(allProducts.length / pageSize)
    
    const pagedProducts = allProducts.slice((page - 1) * pageSize, page * pageSize)

    return (
        <main>
            <h1>Products</h1>
            <ul>
                {pagedProducts.map((product, i) => (
                    <li key={i}>{product}</li>
                ))}
            </ul>
            <ServerPagination currentPage={page} totalPages={totalPages} />
        </main>
    )
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Styling-CSS,Fonts,Images
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

CSS:
1.Global CSS
2.CSS Modules
3.CSS Framworks
  ->Tailwind framwork
  ->bootstrap
  ->SASS
4.CSS in js

In React How to apply css:

<div className="flex">

const styles= {
    backgroundColor:'red'
}
<div style={styles}>
<div style={{backgroundColor:'red'}>

√ What is your project named? ... styling-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								  How to use Tailwind framework


export default function Home() {
  return <div className="m-20">
    <p className="text-xs">This is tailwind</p>
    <p className="text-sm">This is tailwind</p>
    <p className="text-base">This is tailwind</p>
    <p className="text-lg">This is tailwind</p>
    <p className="text-xl">This is tailwind</p>
    <p className="text-3xl">This is tailwind</p>
    <p className="text-3xl font-black">This is tailwind</p>
    <p className="text-3xl font-black text-blue-900 ">This is tailwind</p>
    <p className="text-3xl font-black text-blue-900 bg-red-100 ">This is tailwind</p>
    <p className="text-3xl font-black text-blue-900 bg-red-100 ">This is tailwind</p>
    <p className="text-3xl font-black text-blue-900 bg-red-100 ml-10 mt-10 mr-10 rounded-full p-10 ">This is tailwind</p>

  </div>
}
...........................................................................................................................................................................................................................................
										CSS Modules
...........................................................................................................................................................................................................................................
Why CSS Modules?

Local Scope Prevents Clashes: CSS Modules use local scope to avoid style conflicts across different project parts, allowing component-scoped styling.
Clear Style Dependencies: Importing styles into their respective components clarifies which styles impact which areas, enhancing code readability and maintenance.
Solves Global Scope Problems: CSS Modules prevent the common issue of styles in one file affecting the entire project by localizing styles to specific components.
Boosts Reusability and Modularity: CSS Modules allow the same class names in different modules, promoting modular, reusable styling.

Module Syntax:
YourName.module.css

src/app/profile/profile.module.css

.profile {
    max-width: 400px;
    margin: 0 auto;
    padding: 20px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    background-color: #ffffff;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.profileImage {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    margin-bottom: 16px;
    object-fit: cover;
}

.name {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 8px;

}

.bio {
    font-size: 1rem;
    color: #4a5566;
    line-height: 1.5;

}

src/app/profile/page.js
import styles from '@/app/profile/profile.module.css'

export default function ProfilePage() {
    const profile = {
        name: 'Subramanian Murugan',
        bio: 'Next.js Trainer | Micro services Consultant | Open Source Contributor'
    }
    return <div className={styles.profile}>
        <h1 className={styles.name}>{profile.name}</h1>
        <p className={styles.bio}>{profile.bio}</p>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									css in js using style attribute
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

import styles from '@/app/profile/profile.module.css'

export default function ProfilePage() {
    const profile = {
        name: 'Subramanian Murugan',
        bio: 'Next.js Trainer | Micro services Consultant | Open Source Contributor'
    }
    return <div className={styles.profile}>
        <h1 style={{ backgroundColor: 'yellowgreen' }} className={styles.name}>{profile.name}</h1>
        <p className={styles.bio}>{profile.bio}</p>
    </div>
}
............................................................................................................................................................................................
								External Stylesheets
..........................................................................................................................................................................................

Steps:
1.install bootstrap
   npm i -D bootstrap
2.import in the root layout

src/app/layout.js

import 'bootstrap/dist/css/bootstrap.css'

.........................................................................................................................................................................................................................................
			      					Image Handling
...........................................................................................................................................................................................................................................

Next.js comes with automatic image optimization for better performance and user experiences.

How to handle static assets?

You can store all static assets such as images,fonts,docments under public folder in the root directory

if you are going to access any static assets inside code , you can use "/".

Image: 
 Next.js provides Image component which extends HTML <img> element.

How to use Image component?

 next/image package 

<Image src="" alt="">

src property can point local image or remote image.

How to use local image?

import Image from "next/image"
export default function ImagePage() {

    return <div>
        <Image src="/next.svg" alt="This is Next logo" height={100} width={100} />
        <Image src="/window.svg" alt="This is Next logo" height={100} width={100} />

    </div>
}

How to handle Remote Images?

import Image from "next/image"

export async function fetchProducts() {
    const url = 'https://fakestoreapi.com/products'
    const response = await fetch(url)
    return response.json()
}

export default async function ProductsPage() {
    const products = await fetchProducts()
    return <div className="m-10 p-5">
        {
            products.map(product => {
                return <section key={product.id}>
                    <h2>{product.id}</h2>
                    <h3>{product.title}</h3>
                    <Image src={product.image} height={200} alt={product.title} width={200} />
                </section>
            })
        }
    </div>
}
After adding, you will get compile time error

Invalid src prop (https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_t.png) on `next/image`, hostname "fakestoreapi.com" is not configured under images in your `next.config.js`
See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host

src\app\products\page.js (17:21) @ <anonymous>


  15 |                     <h2>{product.id}</h2>
  16 |                     <h3>{product.title}</h3>
> 17 |                     <Image src={product.image} height={200} alt={product.title} width={200} />
     |                     ^
  18 |                 </section>
  19 |             })
  20 |         }

if you are accessing remote images, you must configure the location in next.config.mjs

/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        remotePatterns: [new URL('https://fakestoreapi.com/img/**')],
    }
};

export default nextConfig;

...........................................................................................................................................................................................
								Fonts
........................................................................................................................................................................................

By default Next js supports google fonts.

import { Inter } from "next/font/google";
import "./globals.css";

//inter font configuration
const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
Task:
 You have to build master details page
 Master page must have card layout.
 Detail page must have full information with layouts.

Data Url:
https://fakestoreapi.com/products
1.Using css with proper layouts.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
						   					Data Fetching
...........................................................................................................................................................................................................................................

Where data fetching can happen?

Types of Data fetching:

1.Server side data fetching
2.Client side data fetching.

Server side data fetching:
..........................................
=>Whenever possible , we recommend fetching data on the server,This allows you to
 Have direct access to back end data resources(eg.databases)

=>Keep your application more secure by preventing sensitive information, such as access tokens and API Keys, from being exposed to the client.

=>Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.

=>Reduce client-server waterfalls.

=>Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.
....................................................................................................................................................................................................................................
                                               			   Fetching Data Where It's Needed
....................................................................................................................................................................................................................................

	If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally(without using context or redux), nor forward props between components.
	 Instead, you can use fetch or React cache in the component that needs the data without worrying about the performance implications of making multiple requests for the same data.

Parent - Layout  - apicall url eg fetch('/api/customers')
   |
   child  - Layout -apicall sameurl -fetch('/api/customers')
     |
     child -Layout -apicall sameurl -fetch('/api/customers')
       |
      child -Layout -apicall sameurl -fetch('/api/customers')
        |
        child- Page -apicall sameurl -fetch('/api/customers')

........................................................................................................................................................................................................................................
				  						Server side data fetching using "fetch" api
........................................................................................................................................................................................................................................

Fetching data on the server with fetch api:
...............................................................

	Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.

React extends fetch to automatically memoize fetch requests while rendering a React component tree.

There are four places You can use "fetch":

1.Server components
2.Client Components
3.Route Handlers,REST API
4.Server Actions


You can use fetch with async/await in "Server Components", in "Route Handlers", and in "Server Actions".

√ What is your project named? ... data-fetching
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*

.........................................................................................................................................................................................................................................
	    						Data Fetching from external API using "fetch" api
.........................................................................................................................................................................................................................................

Server component:

src/app/todos/page.js

//data fetching in server component using fetch 
export async function fetchTodos() {
    try {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        const response = await fetch(url)
        return response.json()
    }
    catch (err) {
        return err
    }

}

export default async function TodosPage() {
    const todos = await fetchTodos()
    return <>
        <h1>Todos Page</h1>
        <ul>
            {todos.map(todo => <li key={todo.id}>{todo.title}</li>)}
        </ul>
    </>
}
...........................................................................................................................................................................................................................................
							  Server side data fetching using  "third party" api-axios
.........................................................................................................................................................................................................................................
	You can use any third party ajax api to call apis from next application but which is not recommended, because other apis will not have features such as caching,revalidation,request memoziation, we have to write extra code.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
			  	 			Data fetching in Client components-Using fetch api
.......................................................................................................................................................................................................................................


Note: 
    fetching in client component mostly not recommended but still we can..

src/app/posts/components/FetchPost.jsx

'use client'

import { useEffect, useState } from "react"

export default function FetchPost() {
    const [posts, setPosts] = useState([])
    useEffect(() => {
        async function fetchPostDetails() {
            const url = 'https://jsonplaceholder.typicode.com/posts'
            const response = await fetch(url)
            const posts = await response.json()
            console.log('client')
            setPosts((myposts) => {
                return posts.concat(myposts)
            })
        }

        fetchPostDetails();


    }, [])

    return <>
        <h1>Posts</h1>
        <ul>
            {
                posts.map(post => {
                    return <li>
                        <span>{post.title}</span>
                    </li>
                })
            }
        </ul>
    </>
}

src/app/posts/page.js
import FetchPost from "./components/FetchPost"

export default function PostPage(){
    return <>
      <FetchPost/>
    </>
}

	Using "fetch" api  in client component is not recommended, the reason is which has no any caching feature is enabled, so fetch must be used only in server components/server side.

					What if i want to write client side data fetching with performance?

 Dont use 'fetch' api

				We have third party lib which internally wraps fetch only with caching features

...........................................................................................................................................................................................................................................
		      		 			Data Fetching in Client Components using SWR API
...........................................................................................................................................................................................................................................

What is SWR?

	 The name “SWR” is derived from "stale-while-revalidate", a HTTP cache invalidation strategy popularized by HTTP RFC 5861. SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.

SWR is wrapper for fetch api only.

Why SWR
1.Client side caching by default
2.Cache revalidation by default
3.You dont need to write hooks like useEffect,useState,
4.You get data,error,loading flags

npm i swr

rc/app/components/PostsClientUsingSWR.jsx

'use client'
import useSWR from "swr"

function fetchposts(...args) {
    return fetch(...args).then(res => res.json())
}

export default function FetchPostsUsingSWR() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetchposts)

    if (error) {
        return <div>
            <h1>Failed to Return</h1>
        </div>
    }
    if (isLoading) {
        return <h1 className="text-center mt-30">Loading...</h1>
    }
    return <ul className="m-10">
        {
            data.map(post => {
                return <li key={post.id}>
                    {post.title}
                </li>
            })
        }
    </ul>


}	
src/app/posts/page.js
import FetchPost from "@/app/components/FetchPosts";
import FetchPostsUsingSWR from "@/app/components/PostsClientUsingSWR"

export default function PostPage(){
    return <div>
        <h1>Post Page Fetching Data from the Client Side</h1>
        {/* <FetchPost/> */}
        <FetchPostsUsingSWR/>
    </div>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 Building REST APIs in Next.js  
...........................................................................................................................................................................................................................................

REST api can be used to write rest api which may talk to databases or external rest api or Graphql api or microservices

Route Handler:
  Route handlers are used to create api in next

File Name:
 route.js


src/app/todos/
   page.js
   layout.js
   route.js - it is not recommended to write like this

Recommended Folder Structure:
.....................................................
src/app/api/todos
    route.js
    	[id]/
    	  route.js

url pattern
 /api/todos 
 /api/posts
 /api/products
 /api/products/1

Syntax:

export async function HTTPVerb(request){

}
=>Always route function must have "export" only.
=>Function must have async keyword
=>Function args may have request object.
=>Return value must be always json

Supported Verbs:

1.GET
2.POST
3.PUT
4.PATCH
5.DELETE
6.HEAD
7.OPTIONS

API Arg:
 NextRequest Object used to handle incoming client request
 NextResponse Object used to send response to the client.

Return Type always be json:
  function name must be marked as "GET/POST"

√ What is your project named? ... rest-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Use case:Simple Rest api

src/app/api/greeter/route.js
import { NextResponse } from "next/server";

export async function GET(req) {
    //resonse
    return NextResponse.json({ message: 'Welcome to Rest api' })
}

Testing:
http://localhost:3000/api/greeter.

Patterns:

1.With Mock data
2.With External REST API
3.With Database

src/app/mock-data/users.js
export default [
    {
        id: 1,
        name: "Leanne Graham",
        username: "Bret",
        email: "Sincere@april.biz",
    },
    {
        id: 2,
        name: "Ervin Howell",
        username: "Antonette",
        email: "Shanna@melissa.tv",

    },
    {
        id: 3,
        name: "Clementine Bauch",
        username: "Samantha",
        email: "Nathan@yesenia.net",

    },
    {
        id: 4,
        name: "Patricia Lebsack",
        username: "Karianne",
        email: "Julianne.OConner@kory.org",

    },
    {
        id: 5,
        name: "Chelsey Dietrich",
        username: "Kamren",
        email: "Lucio_Hettinger@annie.ca",

    },
    {
        id: 6,
        name: "Mrs. Dennis Schulist",
        username: "Leopoldo_Corkery",
        email: "Karley_Dach@jasper.info",

    },
    {
        id: 7,
        name: "Kurtis Weissnat",
        username: "Elwyn.Skiles",
        email: "Telly.Hoeger@billy.biz",

    },
    {
        id: 8,
        name: "Nicholas Runolfsdottir V",
        username: "Maxime_Nienow",
        email: "Sherwood@rosamond.me",

    },
    {
        id: 9,
        name: "Glenna Reichert",
        username: "Delphine",
        email: "Chaim_McDermott@dana.io",

    },
    {
        id: 10,
        name: "Clementina DuBuque",
        username: "Moriah.Stanton",
        email: "Rey.Padberg@karina.biz",

    }
]
src/app/api/users/route.js
import users from "@/app/mock-data/users";
import { NextResponse } from "next/server";

//get all users
export async function GET() {
    return NextResponse.json(users)
}
export async function POST(req) {
    const payload = await req.json()
    //write biz logic to insert new user into db(array)
    const newUser = {
        id: users.length + 1,
        ...payload
    }
    users.push(newUser)
    return NextResponse.json(newUser, { status: 201 })
}
src/app/api/users/[id]/route.js
import users from "@/app/mock-data/users";
import { NextResponse } from "next/server";

// export async function GET(req, obj) {
//     const myparams = await obj.params
//     console.log(myparams.id)
//     return NextResponse.json({ message: 'by id' })
// }

export async function GET(req, { params }) {
    const id = (await params).id
    const user = users.find(tmpUser => tmpUser.id === +id)
    if (!user) {
        return NextResponse.json({ error: `User ${id} not found` }, { status: 404 })
    }
    return NextResponse.json(user)
}
Task:
 You write update, and delete logic
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Query Params
I want to filter data based on certain conditions
for eg: i want to filter data based on email.

URL :
 http://localhost:3000/api/users  - GET - GETALL
   /app/api/users/route.js

http://localhost:3000/api/users/1 - GET - GetBy id
   /app/api/users/[id]/route.js

Query Param URL Pattern:

http://localhost:3000/api/users/search?email=someemail@gmail.com

Folder Struture
/app/api/users/search/route.js

import { NextResponse } from "next/server";

export async function GET(req){
    const { searchParams } = new URL(req.url)
    const email = searchParams.get("email")
    //filter data based on email:
    return NextResponse.json({ email })
}

Task: wrap the biz logic to filter data based on email


